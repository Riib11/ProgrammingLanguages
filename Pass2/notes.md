# Notes## My notationReserved symbols:- //      // comment- :       // seperate term from respective type- :=      // definition- @       // pass reference- |       // seperate constructors and match cases- ?       // matches with anything- →       // function arrow- <->,↔   // "iff", which expands A↔B to A→B /\ B→A- =>,⇒,↦  // arrow for "mapsto"- ,       // seperate names (especially in brackets)- ()      // associative brackets (restricts associativity)- []      // implicit parameter brackets (contained names share type)- {}      // scope brackets- #       // scoped name reference- $       // new scoped name- +       // new unscoped name- %       // unnamed- *       // 'forall'Reserved fundamentals:- still working on thisReserved syntactical sugars:- scope // named, parametrized scopes## Syntax### Statement SyntaxAll statements are or are notations for forms of the following format:    +T = (* (%:%) ... (%:%)          :  % →  ...  → %)The `...` represent that there can be repeated any number of the surrounding phrases. The `*` represents `forall` in a mathematical sense, and in a functional sense represents a type definition. For example,    +P : Nat → Prop.    +P : (* (n:Nat), Prop).### Most Basic Built-in Notations**The colon**. On the left side of the colon, naked symbols are used as terms. On the right side of the colon, naked symbols are used as types.Here are some of the most simple examples, that don't have parameters:    +Type : Type. // +Type : (* , Type).    +Prop : Type. // +Prop : (* , Type).    +Set  : Type. // +Set  : (* , Type).Here are some slightly more complicated examples, with parameters. Notice that `A` is named on the left side of the colon, and then referenced two times - once on the colon-left and once on the color-right. On the colon-left, `A` is the type signature of the new  name    +term : A.     // +term : (* , A).    +func : A → B. // +func : (* , A → B).    // definition    +Nat : Type.    // construction    +Nat_construction : Nat & (Nat → Nat).    // induction    +Nat_induction (P : Nat→Prop)        : P Nat_O        → (* (n:Nat) , P n → P (Nat_S n))        → (* (n:Nat) , P n).    // expanded:    +Nat_induction        : ( * (P : Nat→Prop)            , (P Nat_O)            → (* (n:Nat) , P n → P (Nat_S n))            → (* (n:Nat) , P n)            → (P : Nat→Prop)).Note that    +P : Nat -> Typewhereas    +pf_P (n:Nat) : P n    +pf_P : (* (n:Nat) , P n)### QuantifiersLets have    R : [$A:%] → A → Prop.represent a proposition for an element of `A`. So for `x:A`, `R x` represents the proposition that `R` holds for `x`.Now consider    [$A:%] → forall ($x:A), R x.This translates to    [$A:%] → ($x:A) → R x.The reason that we need to keep stating `[$A:%]` is because we reference it explicitly Note the semantic translation    "forall ($x:A)," --> "($x:A) →"Functionally, this reprents the type of function from `A` to propositions terms of `A`. In other words, it is the position that `R` holds for terms of `A`.Now consider    [$A] (exists ($x:A), R x).This translates to     % : R x.or    % [$x] : R x.So saying that `x`  exists such that `R` holds for `x` is the same as saying that you have a term with the type `R x`.How does this play out in context?    forall (n:Nat), exists m, m ↔ S n.What does this translate to, literally? Here is is, according to the rules above, applied one at a time:    forall (n:Nat), exists m, m ↔ S n.    (n:Nat) → (exists m, m ↔ S n).    (n:Nat) → (% [m:Nat]:m ↔ S n).    % [m:Nat] : (n:Nat) → (m ↔ S n).        % [m:Nat] (n:Nat) : m ↔ S n.Fully expanded, here's what it looks like    % : [m:Nat] → (n:Nat) → ((m → S n) & (S n → m)).which you may prefer to put variable names on the left, so    % [m:Nat] (n:Nat) : (m → S n) & (S n → m).In case you're wondering, this is how name definitions expand:    f [$A] : A → A → A.    f = ( % : [$A:%] → (%:A) → (%:A) → (%:A) )    id [A] ($x:A) : A = x. // polymorphism!    id = ( % : [$A:%] → ($x:A) → (x:A) )    #### 1. Simple    Axiom Type : Type.    Axiom Prop : Type.    Axiom Set  : Type.    Axiom False : Prop = .    // no constructors    Axiom True  : | Prop = I. // one constructor    // Defining Nat    Axiom Nat : Set =         // two constructors        | O : Nat        | S : Nat → Nat.    // the above is syntactical sugar for the following    Axiom Nat : Set.    Axiom O : Nat.    Axiom S : Nat → Nat.    Axiom Nat_ind (n:Nat)        : n ↔ O        | exists m, n ↔ S m    Notation Nat_ind     // Simple notation    Notation Relation [A] = A → A → Prop.    // the [A] is implicitly carried on,    // so it is infered the (x,y,z:A)    Scope With (R : Relation) {        Axiom Reflexive  : R x x.        Axiom Symmetric  : R x y → R y x.        Axiom Transitive : R x y → R y z → R x z.    }    // reflexive, symmetric, transitive    Axiom Equalitive [A] (R : A→A→Prop) → Prop =        | equalitive            : Reflexive R & Symmetric R & Transitive R            → Equalitive R    // which is the same as    Notation Equalitive [A] (R : A→A→Prop)        = Reflexive R & Symmetric R & Transitive R    Equal [A] : A -> A -> Prop.    Nat_Equality : Nat -> Nat -> Prop#### 2. AxiomsAxioms are unitary terms that are self-evident in the way that you write them. Lets start with the most simple possible example expression:    Axiom False : Prop.This is an axiom that decrees `False` to be a term with type `Prop`. There is a recursive notion to how `Prop` was axiomized, but don't worry about that for now. So, all well and good so far. But, what about terms with the type `False`? Well, as simple as this example is, there are no such terms. In fact, `False` has been explicitly defined to not have any terms, a priori, if this program compiles with just this line. In order to make this more explicit, we can use the usual constructor syntax:    Axiom False : Prop = .Since there are no constructor-seperators, `|`, this notation makes it very clear that there are no constructors for `False`. However, as you may guess, you can easily axiomate a term of type `False`, just as `False` was created. So lets see what that looks like:    pf_False : False.So therefor we have broken logic, as having a proof of `False` entails anything, right? Right. And in fact if you wrote these two lines, you indeed have achieved that result. But what is great about it is that it is so clear, right? You can see that, as there exists a proof of `False`, which has no constructors, logic is broken.Axioms are just assumptions, and of course if you assume contradictory things then logic will break down. So you have to be careful, and when your code gets complicated its important to write some proofs to show that the properties you are relying on are in fact true. But don't worry, its not that hard. Its actually much easier that traditional debugging in something like JavaScript. In this typed setting, its easy to see exactly what kinds of problems to look for, and often the compiler will point to the exactly relevant features of a problem. You will rarely have runtime errors if your code compiles.Lets look at some more interesting and more engaging axioms:    Axiom Type : Type.    Axiom Bool : Type.    Axiom Set  : Type.    Axiom Bool : Set :=        | false : Bool        | true  : Bool.So, here we have so inhabited terms. Clearly, the set `Bool` has two inhabitents: `true` and `false`. What is the significance? Well, we can say that, since these axiomatically are distinct, they are in fact distinct. Ok... what's the significance of that? Its that when doing a case analysis of a `b : Bool`, we can say that there are only the two obvious options for `b`. This is aximomatically true. There are no more and no less possibilities, only exactly two. This is extremeley imporant. We can state this as a Theorem, which is just a term `Bool_decidable b : b = true \/ b = false`. Suppose we state, axiomatically,    Axiom b : Bool.This statement reads as "b is a term with type Bool". Since we know `Bool_decidable`, we know that    b_decidable : b = true \/ b = false        := Bool_decidable b.This presents a kind of interesting situation. How do axioms interact? Well, in short, they do not interact directly. For example, if we we to state altogether:    Axiom Set  : Type.    Axiom Bool : Set = | false | true.    Axiom b    : Bool.Keep in mind the following cryptic referenes.        // provided a term of A or a term of B, you have a term of Union A B    Union A B :=        | left  : A -> Union A B        | right : B -> Union A B.    Notation "$A \/ $B" := Union A B.    // provided a term of A and a term of B, you have a term of Product A B    Product A B :=        | both : A -> B -> Product A B.    #### 3. NotationsThe `Notation` keyword defines a symbol that is a synonym for an expression, with some syntactical options associated (infix, etc). The syntax is    Notation " Bool' " := Bool.    // the symbol Bool' is interchangable with the symbol Bool.    // basically, you have a proof of Bool' ↔ Bool.    // infix    Notation "x + y" := plus x y. // where (plus : Nat → Nat → Nat)    // fancy infix    Notation "$rank of $suite" := Card rank suite    // even fancier infix    Notation "a $entity_type of the name $name" := new_Entity entity_type name.        // where (new_Entity : EntityType → String → Entity)### Simple definitionsThere are 3 basic parts to a definition. The newly-introduced symbol, the type expression for the symbol, and the term expression.    Term new-symbol : type-expn := term-expn.    Axioms are terms that are do not have a binding (/term-expn/), so they cannot be /calculated/.    Term new-symbol : type-expn. // doesnt require term-expn### Functions        // named    Term new-symbol var1 var2 ... : type-expn := term-expn.    // anonymous    var1 var2 : typx-expn ↦ term-expn    // combination    Term new-symbol : type-expn        := var1 var2 ... : type-expn ↦ term-expn.### EvaluationBy default, when you evaluate a term, you are getting the value directly. Can also use value references explicitly.    // accessing the value    x.    // referencing the value    @x.    // applying a function    f x.    (f x y) = (f x) (y) = (f) (x) (y) // associativity rules    // passing a value reference    compose @f @g := f1 f2 ↦ f1 f2.    Term f_of_g := @(f g).When defining terms, the right side of the `:=` is lazily evaluated. That is, the value is not computed until explicitly required.### Type Definition`Type`, a synonym for `Term0`, is just a term of `Type1`. The correct interpretation of this type theory is that terms are indistinuishable types in every way except for heirarchy. There is no distinguishing "types" and "kinsd" and such like in GHC. There is just the heirarchical difference between `O`, `Nat`, `Type` and `Type1`, following the relations `O : Nat`, `Nat : Type`, `Type : Type1`.    // example: Bool    Term Bool : Type.        Term True  : Bool.        Term False : Bool.    // example: Nat    Term Nat : Type.        Term O : Nat.        Term S : Nat → Nat.    // example: Maybe    Term Maybe : Type → Type.        Term None [A:Type] : Maybe A.        Term Some (A:Type) : Maybe A.    // syntactical-sugar for inductive types    // these are the same as the corresponding phrases above        Term Nat : Type :=         | O : Nat         | S : Nat → Nat.    Term Bool : Type :=         | True  : Bool         | False : Bool.    Term Maybe (A:Type) → Type         | Some : A → Maybe A         | None : Maybe A.    // can make it even more efficient with inference    Term Nat := | O | S (n:Nat).        Term Bool := | True | False.        Term Maybe (A:Type) : Type := | None | Some (a:A).    Term Prop : Type. // the type for propositions    Term Set  : Type. // the type for sets### Implicit Parameters        // properties are named as adjectives    Term Reflexive [A] [a:A] (R:A→A→Prop) : R a a.    // exhaustive signature:    // Reflexive    //  : [A : ?]    //  → [a : A]    //  → (R : A → A → Prop)    //  → (pf : R a a)    // can instantiate Reflexive like so:    Term Equal [A] : A -> A -> Prop.    Term Equal_reflexivity [A] := Reflexive (Equal A)    // so now can do something like this    Term one_equals_one : Equal 1 1 := Equal_reflexive.    // can define other properties in a similar way    // names in the same curly brackets means they are all the same type    Term Transitive [A] [a,b,c:A] (R:A→A→Prop)        : R a b → R a b → R a c.    // instance    Term Equal_transitivity := Transitive Equal.    // define property    Term Symmetric [A] [a,b:A] (R:A→A→Prop)        : R a b → R b a.    // instantiate property on a relation    // this specific term is a proof that the relation has the property    Term Equal_symmetry := Symmetric Equal.    Term Reflexivity  [A:Type] : A = A.    Term Transitivity [A,B,C:Type] : A = B → B = C →     //---------------------------------------------    // in more compact manner:    // definitions of properties    Term Reflexive  [A] [x:A]     (R:A→A→Prop) : R x x.    Term Symmetric  [A] [x,y:A]   (R:A→A→Prop) : R x y → R y x.    Term Transitive [A] [x,y,z:A] (R:A→A→Prop) : R x y → R y z → R x z.    // instantiation of properties (axiomatic proofs of properties)    Term Equal_reflexivity  := Reflexive Equal.    Term Equal_symmetry     := Symmetric Equal.    Term Equal_transitivity := Transitivity Equal.    //---------------------------------------------    // some syntactical sugar:    // all names in scope gain parameters    // "Term" at the beginning of each line is implicit    Scope With [A] [x,y,z : A] (R : A → A → Prop) {        Reflexive  : R x x;        Symmetric  : R x y → R y x;        Transitive : R x y → R y z → R x z;    }.    // binary relation    Term Relation : Type -> Type -> Prop.    Term Equality A B : Relation A B.        // equality    Term Equal [A] : A -> A -> Prop.    // instantiation    Scope Equality_props With [A] {        refl  := Reflexive  Equal;        sym   := Symmetric  Equal;        trans := Transitive Equal;    }.    // reference rules:    Equality_props#trans. // has type '[A:?] -> [x,y,z:A] -> Equal x y -> Equal x z'### ComputationCan explicitly require a value to be calculated. This allows running programs, in the case of starting an IO event sequence, for example. The side effects are explicitly encoded in the relevant types (for example, IO monad).        Term compute : Program → IO