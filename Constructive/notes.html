<!DOCTYPE html><html><head><meta charset="utf-8"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAABE0AA8AAAAAHWwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABWAAAADsAAABUIIslek9TLzIAAAGUAAAAQwAAAFY3d1HZY21hcAAAAdgAAACqAAACOvWLi0FjdnQgAAAChAAAABMAAAAgBtX/BGZwZ20AAAKYAAAFkAAAC3CKkZBZZ2FzcAAACCgAAAAIAAAACAAAABBnbHlmAAAIMAAABdQAAAjkYT9TNWhlYWQAAA4EAAAAMwAAADYQ6WvNaGhlYQAADjgAAAAfAAAAJAc6A1pobXR4AAAOWAAAACAAAAA0Kmz/7mxvY2EAAA54AAAAHAAAABwQPBJubWF4cAAADpQAAAAgAAAAIAEHC/NuYW1lAAAOtAAAAYQAAALxhQT4h3Bvc3QAABA4AAAAfgAAAMS3SYh9cHJlcAAAELgAAAB6AAAAhuVBK7x4nGNgZGBg4GIwYLBjYHJx8wlh4MtJLMljkGJgYYAAkDwymzEnMz2RgQPGA8qxgGkOIGaDiAIAJjsFSAB4nGNgZHZmnMDAysDAVMW0h4GBoQdCMz5gMGRkAooysDIzYAUBaa4pDA4Pwz+yMwf9z2KIYg5imAYUZgTJAQDcoQvQAHic7ZHNDYJAFIRnBXf94cDRIiyCKkCpwFCPJ092RcKNDoYKcN4+EmMPvpdvk539zQyAPYBCXEUJhBcCrJ5SQ9YLnLJe4qF5rdb+uWPDngNHTkta101pNyWa8lMhn6xx2dqUnW4q9YOIhAOOeueMSgsR/6ry+P7O5s6xVNg4chBsHUuFnWNJ8uZYwrw7chrsHXkODo7cB0dHOYCTY8kv0VE2WJKD6gOlWjsxAAB4nGNgQAMSEMgc9D8LhAESbAPdAHicrVZpd9NGFB15SZyELCULLWphxMRpsEYmbMGACUGyYyBdnK2VoIsUO+m+8Ynf4F/zZNpz6Dd+Wu8bLySQtOdwmpOjd+fN1czbZRJaktgL65GUmy/F1NYmjew8CemGTctRfCg7eyFlisnfBVEQrZbatx2HREQiULWusEQQ+x5ZmmR86FFGy7akV03KLT3pLlvjQb1V334aOsqxO6GkZjN0aD2yJVUYVaJIpj1S0qZlqPorSSu8v8LMV81QwohOImm8GcbQSN4bZ7TKaDW24yiKbLLcKFIkmuFBFHmU1RLn5IoJDMoHzZDyyqcR5cP8iKzYo5xWsEu20/y+L3mndzk/sV9vUbbkQB/Ijuzg7HQlX4RbW2HctJPtKFQRdtd3QmzZ7FT/Zo/ymkYDtysyvdCMYKl8hRArP6HM/iFZLZxP+ZJHo1qykRNB62VO7Es+gdbjiClxzRhZ0N3RCRHU/ZIzDPaYPh788d4plgsTAngcy3pHJZwIEylhczRJ2jByYCVliyqp9a6YOOV1WsRbwn7t2tGXzmjjUHdiPFsPHVs5UcnxaFKnmUyd2knNoykNopR0JnjMrwMoP6JJXm1jNYmVR9M4ZsaERCICLdxLU0EsO7GkKQTNoxm9uRumuXYtWqTJA/Xco/f05la4udNT2g70s0Z/VqdiOtgL0+lp5C/xadrlIkXp+ukZfkziQdYCMpEtNsOUgwdv/Q7Sy9eWHIXXBtju7fMrqH3WRPCkAfsb0B5P1SkJTIWYVYhWQGKta1mWydWsFqnI1HdDmla+rNMEinIcF8e+jHH9XzMzlpgSvt+J07MjLj1z7UsI0xx8m3U9mtepxXIBcWZ5TqdZlu/rNMfyA53mWZ7X6QhLW6ejLD/UaYHlRzodY3lBC5p038GQizDkAg6QMISlA0NYXoIhLBUMYbkIQ1gWYQjLJRjC8mMYwnIZhrC8rGXV1FNJ49qZWAZsQmBijh65zEXlaiq5VEK7aFRqQ54SbpVUFM+qf2WgXjzyhjmwFkiXyJpfMc6Vj0bl+NYVLW8aO1fAsepvH472OfFS1ouFPwX/1dZUJb1izcOTq/Abhp5sJ6o2qXh0TZfPVT26/l9UVFgL9BtIhVgoyrJscGcihI86nYZqoJVDzGzMPLTrdcuan8P9NzFCFlD9+DcUGgvcg05ZSVnt4KzV19uy3DuDcjgTLEkxN/P6VvgiI7PSfpFZyp6PfB5wBYxKZdhqA60VvNknMQ+Z3iTPBHFbUTZI2tjOBIkNHPOAefOdBCZh6qoN5E7hhg34BWFuwXknXKJ6oyyH7kXs8yik/Fun4kT2qGiMwLPZG2Gv70LKb3EMJDT5pX4MVBWhqRg1FdA0Um6oBl/G2bptQsYO9CMqdsOyrOLDxxb3lZJtGYR8pIjVo6Of1l6iTqrcfmYUl++dvgXBIDUxf3vfdHGQyrtayTJHbQNTtxqVU9eaQ+NVh+rmUfW94+wTOWuabronHnpf06rbwcVcLLD2bQ7SUiYX1PVhhQ2iy8WlUOplNEnvuAcYFhjQ71CKjf+r+th8nitVhdFxJN9O1LfR52AM/A/Yf0f1A9D3Y+hyDS7P95oTn2704WyZrqIX66foNzBrrblZugbc0HQD4iFHrY64yg18pwZxeqS5HOkh4GPdFeIBwCaAxeAT3bWM5lMAo/mMOT7A58xh0GQOgy3mMNhmzhrADnMY7DKHwR5zGHzBnHWAL5nDIGQOg4g5DJ4wJwB4yhwGXzGHwdfMYfANc+4DfMscBjFzGCTMYbCv6dYwzC1e0F2gtkFVoANTT1jcw+JQU2XI/o4Xhv29Qcz+wSCm/qjp9pD6Ey8M9WeDmPqLQUz9VdOdIfU3Xhjq7wYx9Q+DmPpMvxjLZQa/jHyXCgeUXWw+5++J9w/bxUC5AAEAAf//AA94nIVVX2hbZRQ/5/t7893s5ja9f7ouzdZ0TTqz3bRJmogbWya6bG6Cq0VbSV2ddIJjFtfIQHEig80Hda8yUN/0YQz8AyriiyD+xQd92R4HCnaCb3samnpumrpsCsLlfPf7zvedc37nL3CAtc/5W/wQZGA3tOBSY/g+TMjHmwzEoM1Q8+ZjRZY4oJhmBw5/YB6Za0yC5AkhlwA1A1yCBIBOwCII0Cj0U8BAMdUCzq05sKwkP7SlUY6fcJk4Fb/RyE79/6P5hjM/F4aZiXBoeMgzcqQ4Xi1hPqfDLG5FT+lchCVU3lYMyvuwhl1mqndQL0RsuloLywHtthLXI06OblTrhfWVnpSJ5+mwu/JdbtuN3IAnkW0LLMcRwaC7ktrlzridM6kVdyf9uO1UNBByI7JhwtG2sEwab07ORBeilWhqavJCqV0qzZTOl/7ZXQ5TbTcdcFelyGhhRDAQpdqp1FEX3w3cFTc1k9pJQkmm4ySCbSikxRP2QOfN+0tHS5MrpQuTU1Mk5nw0E5Xa0WvrOwDyGax9yB9ma6DAg82wHc43SAGTI4GjBWebOePAERFE8/AHaQpZASSTy8A4WwZiLQMQ82mFKATO0ILicRAoDm9p5P99E5b/fXG+kQYY3TYUuqmERWYoT0u/GNYL2q/4WB3LaVS+VynXsVYIcWw6DkCh3nX1D+VzlYN4LClF5yexSQos8exqZ3KVP+wtrC54u4Nznq6cq+xpMpUUnZ8FUYzE86ud0g28NOIv3Gj5/rmA3ABs7S/ywzFuQ4qyd6QxfNtiQIaEgp3w/entQg4Vcbqa16M5FfpeUB8t1+qeg7mI7cUyOe79wOk86gSxkVec4KPTX69++5x68Yubn5/F+w52z7u08sJX7fZXv8ekT/d2mILJxq6sn+SC6qEJknzLJCxyZEKwWVqYmAPBxBE/9DLeZiWHu7lcr/VytrCRuHojncNuTt9h46tmacmYisnSamdN2bZptcsmSysdVsy1PrOvOzF3xN64Rb937t/og9KHxYdcjIUqFAmIAHGHNzlns+RTPgeUYAQm9DwpNxfxbhhBHPaw3/gfTcXO2L+eJVIx5nsyGkvm9X4/f+bGkH45G0PaSjcMXTjcZyTvi3UdHoCDjQd3IDUVsgwYmUoJK/gp4JJxeRI0MKHZIkgynyIBqBTOUs6rOVCojvjZ4mCQz49ZMlMcp8QoYk6NoBfsxnJtsBohpa8iGJS+ZH7gU7NxME6cmF+t7cO9vB8d3jTWSct0ycW9ranXmolNDwmVkNnxe+8JtoztwS5rKJ0xWS95tQ/1zMYzg69MzUZnNtl1ofNbsml/OJm6f9wjRjpnu2o4MzHzn77IQkRd+1DjwMQ2pqSjGMMhyjrgTbBAKksuUm0iU7hI0aN2wOKOq7WYBSH0HGihj/jkiPxAfmwsEbfYrjMG+j3ij932Db/LV7I/xruNrhnroxjR9HRMb2nTvO0ZXOoHPk8H2ZhDPx93qcE/53sH5np/dkIP7zzhTVKdR/BAY/9ElkkR+A6lJGsqpJ4oQcTxpvBT3Kn58VkaJjgHyPEIws57xkaHh9KuVpDEpJZeMbZ5w/zBHi5NMQ4r5VphsFqID7TyB9eR4pX216c3AHxpdAwoqU9qg0ZJ6yVLKmMSz1iG2z27ifx18NkY0LPx1W/wCc2l5LrznrIsiKsqbmB78A9wIGx4tI8rjihVHJyY9pgMirenVq0yWg7Iw7eogG7ZgYM3qR9959A/fZkg6MnD/exlkmc+jWV4SB15XUR+eqC6l6ZmgPtN9z5JMfik05OV8ljylunJ4J+wA/FUaQSSKotsYsCWqaPBidBLcxkWx7XKFRIb45TGaEhjlF9uUVPqXOtcIwsXbBvfoZXIyRYFdkfnqjExH98xpnPczqzjX/uNdO1Y17Wpi5+6Ts8BXtjVFasp9KZ1mOiNbH65c5w6HgmyF2jFCZywM8mWjRc7T5Pmt0lRy7Y71+jYbpGyvwG4sH0XeJxjYGRgYADiwBB/53h+m68M3MwvgCIM1z5N/g6j///9v5H5BbMnkMvBwAQSBQCIcA9gAHicY2BkYGAO+p8FJF/8//v/F/MLBqAICuAFALYQB5kAeJxjfsHAwLwAiCNB+P9fbJjJmoGBMRUo/wKCAfO2EnQAAAAAANoBXgGcAgICVALaA1IDvAPkBAYEPARyAAEAAAANAF0ABAAAAAAAAgAUACQAcwAAAG4LcAAAAAB4nHWRzWrCQBSFT+pPqUIXLXTTzayKUohGKIibCoLuhbrrYtTRxCYZmYyKyz5Fd32HvlDfoO/QkziIFJtw9bvnnpl7ZwLgBt/wcHieGAf2UGd24Atcou+4RH3kuEweO66QXx1XyaHjGh6ROa7jFp/cwStfMVvhy7GHO+/e8QWuvcBxifqz4zL5xXGF/Oa4Sn53XMPE+3Bcx4P3M9DrvYmWoRWNQVN02kFXTPdCU4pSGQu5saE2meiLhU6timPtz3SSs9ypTCdqrJabWJoT5QQnymSRTkXgt0/UkUqVkVbN807ZdtmxdiEWRidi6HqItdErNbN+aO2612qd9sYAGmvsYRBhyUu0EGhQbfK/gzYCdElTOgSdB1eEFBIxFYkNV4RFJWPeZyyYpVQVHTHZx4y/yVGX2LGWFZri51TccUOn5B7nPefVCSPvGhVVwUl9znveO2KkhV8Wk82PZ8qwZf8OVcu1+fSmWCMw/HMOwXvKaysqM+p+cVuWag8tvv+c+xdd+4+teJxtjUEOwiAURJla24KliQfhUA2g/Sl+CKXx+loNrpzVezOLEY34Ron/0WhwQoszOvQYIKFwwQiNSbSBeO2SZ0tBP4j3zVjKNng32ZmtD1VVXCuOiw/pJ8S3WOU6l+K5UOTaDC4+2TjKMtN9KQf1ezLx/Sg/00FCvABHhjDjAAB4nGPw3sFwIihiIyNjX+QGxp0cDBwMyQUbGVidNjEwMmiBGJu5mBg5ICw+BjCLzWkX0wGgNCeQze60i8EBwmZmcNmowtgRGLHBoSNiI3OKy0Y1EG8XRwMDI4tDR3JIBEhJJBBs5mFi5NHawfi/dQNL70YmBhcADHYj9AAA) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* Multimarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><style>/*github*/
.codehilite {background-color:#fff;color:#333333;}
.codehilite .hll {background-color:#ffffcc;}
.codehilite .c{color:#999988;font-style:italic}
.codehilite .err{color:#a61717;background-color:#e3d2d2}
.codehilite .k{font-weight:bold}
.codehilite .o{font-weight:bold}
.codehilite .cm{color:#999988;font-style:italic}
.codehilite .cp{color:#999999;font-weight:bold}
.codehilite .c1{color:#999988;font-style:italic}
.codehilite .cs{color:#999999;font-weight:bold;font-style:italic}
.codehilite .gd{color:#000000;background-color:#ffdddd}
.codehilite .ge{font-style:italic}
.codehilite .gr{color:#aa0000}
.codehilite .gh{color:#999999}
.codehilite .gi{color:#000000;background-color:#ddffdd}
.codehilite .go{color:#888888}
.codehilite .gp{color:#555555}
.codehilite .gs{font-weight:bold}
.codehilite .gu{color:#800080;font-weight:bold}
.codehilite .gt{color:#aa0000}
.codehilite .kc{font-weight:bold}
.codehilite .kd{font-weight:bold}
.codehilite .kn{font-weight:bold}
.codehilite .kp{font-weight:bold}
.codehilite .kr{font-weight:bold}
.codehilite .kt{color:#445588;font-weight:bold}
.codehilite .m{color:#009999}
.codehilite .s{color:#dd1144}
.codehilite .n{color:#333333}
.codehilite .na{color:teal}
.codehilite .nb{color:#0086b3}
.codehilite .nc{color:#445588;font-weight:bold}
.codehilite .no{color:teal}
.codehilite .ni{color:purple}
.codehilite .ne{color:#990000;font-weight:bold}
.codehilite .nf{color:#990000;font-weight:bold}
.codehilite .nn{color:#555555}
.codehilite .nt{color:navy}
.codehilite .nv{color:teal}
.codehilite .ow{font-weight:bold}
.codehilite .w{color:#bbbbbb}
.codehilite .mf{color:#009999}
.codehilite .mh{color:#009999}
.codehilite .mi{color:#009999}
.codehilite .mo{color:#009999}
.codehilite .sb{color:#dd1144}
.codehilite .sc{color:#dd1144}
.codehilite .sd{color:#dd1144}
.codehilite .s2{color:#dd1144}
.codehilite .se{color:#dd1144}
.codehilite .sh{color:#dd1144}
.codehilite .si{color:#dd1144}
.codehilite .sx{color:#dd1144}
.codehilite .sr{color:#009926}
.codehilite .s1{color:#dd1144}
.codehilite .ss{color:#990073}
.codehilite .bp{color:#999999}
.codehilite .vc{color:teal}
.codehilite .vg{color:teal}
.codehilite .vi{color:teal}
.codehilite .il{color:#009999}
.codehilite .gc{color:#999;background-color:#EAF2F5}
</style><title>notes</title></head><body><article class="markdown-body"><h1 id="craft">Craft<a class="headerlink" href="#craft" title="Permanent link"></a></h1>
<p>A dependently-type programming language with rewrite-based syntax designed to be a simple and single.</p>
<h2 id="common-terms">Common Terms<a class="headerlink" href="#common-terms" title="Permanent link"></a></h2>
<ul>
<li>
<p><strong>Axiom</strong>: When you are using <code>Axiom</code> to introduce a term, you are just <em>asserting</em> that the (now referencable) term has the specified type and nothing more.</p>
</li>
<li>
<p><strong>Build</strong>: When you are using <code>Define</code> to introduce a term, you are <em>building</em> a term of the correct type using other terms.</p>
</li>
<li>
<p><strong>Construct</strong>: When you are building a term of, say, type <code>X</code> using one of the constructors specified when you defined <code>X</code>, only then are you <em>constructing</em> a term of <code>X</code>.</p>
</li>
</ul>
<h2 id="special-symbols">Special Symbols<a class="headerlink" href="#special-symbols" title="Permanent link"></a></h2>
<p>syntax
<code>:</code>,<code>=</code>,<code>≠</code>,<code>|</code>,</p>
<p>arrows
<code>→</code>, <code>↦</code>, <code>↔</code></p>
<p>logic
<code>∧</code>, <code>∨</code>, <code>∀</code>, <code>∃</code></p>
<p>special
<code>#</code></p>
<h2 id="notes-notation">Notes Notation<a class="headerlink" href="#notes-notation" title="Permanent link"></a></h2>
<p><code>#</code> specifies the rest of a line to be ignored programatically, in a code block.</p>
<ul>
<li>
<p><code>#&gt;</code> signifies that the following comment is supposed to be the debug output of the code on the left of the <code>#&gt;</code>.</p>
</li>
<li>
<p><code>#:</code> signifies that the following comment is supposed to be the signature of the term on the left.</p>
</li>
</ul>
<p><code>###</code>&hellip;<code>###</code> specifies a spanning comment section (can be multiline).</p>
<h2 id="types">Types<a class="headerlink" href="#types" title="Permanent link"></a></h2>
<h3 id="type-the-type">Type, the Type<a class="headerlink" href="#type-the-type" title="Permanent link"></a></h3>
<div class="codehilite"><pre>Axiom Type : (Type1 : (Type2 ...))
</pre></div>


<p>The type <code>Type</code> is a synonym for <code>Type0</code>, the base <strong>level type</strong>, as is the type of <code>Prop</code> and <code>Set</code>.</p>
<h3 id="prop-type-impredicative">Prop Type (Impredicative)<a class="headerlink" href="#prop-type-impredicative" title="Permanent link"></a></h3>
<div class="codehilite"><pre>Axiom Prop : Type
</pre></div>


<p>The type <code>Prop</code> is impredicative and has proof-irrelevant terms (have <code>∀ p1 p2:P, p1=p2</code>). As such, <code>Prop</code> constructions are discarded for program execution. There two built-in inhabitants of <code>Prop</code>, which are <code>True</code> and <code>False</code> (they are detailed later on). Props are useful for propositions that don&rsquo;t don&rsquo;t have a computational component.</p>
<p>An example, <code>Equal : A → A → Prop</code> is the <code>Prop</code> representing equality in <code>A</code>, where <code>A</code> is a type. The introduction rule for <code>Equal</code> is simply <code>∀ a:A, Equal a a</code>. So, if you have a term of type <code>Equal x y</code>, then you know that <code>x</code> equals <code>y</code>, and you can ignore, comptuationally, why. <code>Equal</code> is defined as so:</p>
<div class="codehilite"><pre>Axiom Equal {A : Type} : A → A → Prop :=
| reflexive : ∀ (x : A), Equal x x

Pattern &quot;x = y&quot; := Equal x y
</pre></div>


<h3 id="negative-types-functions">Negative Types (Functions)<a class="headerlink" href="#negative-types-functions" title="Permanent link"></a></h3>
<p>The negative types are characterized having elimination rules. You can <em>use</em> a negative type by <em>applying</em> it. You can <em>construct</em> a negative type by specifying the result of its application.</p>
<p>For example, <code>id {A : Type} : A → A</code> is a negative type with the elimination rule <code>id x ↦ x</code>. <code>id</code> is defined like so:</p>
<div class="codehilite"><pre>Define id {A : Type} : A → A := x ↦ x
</pre></div>


<h3 id="positive-types">Positive Types<a class="headerlink" href="#positive-types" title="Permanent link"></a></h3>
<p>The positive types are characterized by having introduction rules. You can <em>use</em> a positive type by specifying a new term of the positive type using the introduction rule parameters. You can <em>construct</em> a positive type by by <strong>applying</strong> the introduction rule.</p>
<p>For example, <code>And : Prop → Prop → Prop</code> is a positive type with the constructor <code>And.intro : ∀ A B, And A B</code>. <code>And</code> is defined like so:</p>
<div class="codehilite"><pre>Axiom And : Prop → Prop → Prop :=
| intro : ∀ (A B : Prop), And A B
</pre></div>


<p>You know its a positive type because you defined it using the <code>|</code> constructor syntax, where each <code>|</code> indicates the start of a constructor. Positive types come with a few special features automatically:</p>
<h5 id="constuctor"><code>*.constuctor</code><a class="headerlink" href="#constuctor" title="Permanent link"></a></h5>
<p>This axiom is defined along with your type, and you generally never have to use it directly. It&rsquo;s a type sum of the constructors that you defined by name using the <code>|</code>s. For example, if you defined a type</p>
<div class="codehilite"><pre>Axiom X : Set :=
| A : X
| B : X → X
| C : X → X → X
</pre></div>


<p>then you get</p>
<div class="codehilite"><pre>Axiom X.constructor : (Unit) * (Unit → Unit) * (Unit → Unit → Unit)
</pre></div>


<p><code>Unit</code> is a kind of building block for positive types in this way. Also automatically defined with <code>X</code> would be the shorthands</p>
<div class="codehilite"><pre>Scope Open X
Define A := fst (fst constructor)
Define B := snd (fst constructor)
Define C := snd constructor
</pre></div>


<p>as the constructor&rsquo;s type expression associatively expands (left) to</p>
<div class="codehilite"><pre>((Unit) + (Unit → Unit)) + (Unit → Unit → Unit)
</pre></div>


<h5 id="eqaulity"><code>*.eqaulity</code><a class="headerlink" href="#eqaulity" title="Permanent link"></a></h5>
<p>Equality for positive types is predicated on constructive nestequality, especially for dependent types. Equality is already built-in independently as</p>
<div class="codehilite"><pre>Axiom Equal {A : Type} : A → A → Prop :=
| reflexivity : ∀ (x : A), Equal x x
</pre></div>


<p>So <code>*.nestequality</code> implements a method for constructing equality for positive types. For our example type <code>X</code>, we get</p>
<div class="codehilite"><pre>Scope Open X
Axiom nestequality
    : ∀ (x1 x2 x3 x4 : X)
    , A = A
    ∧ x1 = x2 → B x1 = Bx2
    ∧ x1 = x3 → x2 = x4 → C x1 x2 = C x3 x4
</pre></div>


<p>Using the keyword <code>nestequality</code> you can build an equality that automatically extracts the right part of the and clause in <code>*.nestequality</code> and applies your arguments to it (in order). For example,</p>
<div class="codehilite"><pre>Scope Open B
Define test : C A A = C A A :=
    nestequality r r 
    where r : A = A := nestequality A
</pre></div>


<p>This may seem like a roundabout way to construct equality, and it is, sort of, but it can beuseful sometimes. For example, it allows you to explicitly extract the terms you need to provide to construct the higher-level equality that you want.</p>
<p><em>Note</em>: <code>nestequality</code> is in an overloaded reference in the third line of the example above. How is it handled? Well, <code>X.nestequality</code> has the lengthy type specified slightly higher above doesn&rsquo;t have the type <code>A = A → A = A → C A A = C A A</code>, but just plain <code>nestequality</code> can, so it is used!</p>
<h5 id="match"><code>*.match</code><a class="headerlink" href="#match" title="Permanent link"></a></h5>
<p>To take advantage of <code>*.constructor</code> in the most obvious way, you can pattern match with it, and thats exactly what <code>*.match</code> implements for each positive type individually. So, for our type <code>X</code> from earlier, you get</p>
<div class="codehilite"><pre>Scope Open X
Axiom match : ∀ (x:X)
    , x = A
    ∨ x = B
    ∨ x = C
</pre></div>


<p>In other words, if you have an <code>x:X</code>, you know it had to be constructed using one of <code>X</code>&lsquo;s constructors. If you somehow assume via axiom that there&rsquo;s an <code>x:X</code> that doesn&rsquo;t follow thing rule, then you&rsquo;ve got yourself a contradiction so don&rsquo;t do that! There&rsquo;s a reason its set up this way, trust me. <code>*.match</code> is used by the <code>match</code> keyword, which is explained in the <a href="#keywords-special-symbols">Keywords and Special Symbols</a> section.</p>
<h5 id="discriminate"><code>*.discriminate</code><a class="headerlink" href="#discriminate" title="Permanent link"></a></h5>
<p>Combining the logic of <code>*.equality</code> and <code>*.match</code>, you get the extremeley useful constructor discrimination rule. This rule allows you to draw a contradiction from any expression that asserts the <code>*.equality</code> of two terms of a positive type when the terms are no constructred with the same constructor. Formally, for our type <code>X</code> again,</p>
<div class="codehilite"><pre>Scope Open X
Axiom discriminate
    : ∀ (x y x1 x2 : X)
    , A ≠ B x1
    ∧ A ≠ C x1 x2
    ∧ B x ≠ A
    ∧ B x ≠ C x1 x2
    ∧ C x y ≠ A
    ∧ C x y ≠ B x1
</pre></div>


<p>which may seem like a lot at first, but its actually extremeely structured. It&rsquo;s constructred from the possible combinations of the constructors, that&rsquo;s all. Take a minute to look it over. Using the <code>discriminate</code> keyword will search through the relevant <code>*.discriminate</code> property and produced the counterexample you&rsquo;re looking for, as described in the <a href="#keywords-special-symbols">Keywords and Special Symbols</a> section.</p>
<h3 id="set-type-predicative">Set Type (Predicative)<a class="headerlink" href="#set-type-predicative" title="Permanent link"></a></h3>
<div class="codehilite"><pre>Axiom Set : Type
</pre></div>


<p>The <code>Set</code> type is a positive type that is predicative and has proof-relevant terms (possible to have <code>∃ s1 s2:S, s1≠s2</code>). Sets are useful for computation.</p>
<p>An example <code>Bool : Set</code>, is a set of two elements, <code>true</code> and <code>false</code>. It&rsquo;s very important to keep these distinct for computation! <code>Bool</code> is defined like so:</p>
<div class="codehilite"><pre>Axiom Bool : Set :=
| true  : Bool
| false : Bool
</pre></div>


<h3 id="unit-types-unit-true-and-null">Unit Types (Unit, True, and Null)<a class="headerlink" href="#unit-types-unit-true-and-null" title="Permanent link"></a></h3>
<p>The unit types are derivable from any context. In other words, they are positive types with a single constructor, <code>Unit.intro : Unit</code>.</p>
<p>There are three flavors of unit types built-in, which are <code>Unit : Type</code>, <code>True : Prop</code>, and <code>Null : Set</code>. They are defined like so:</p>
<div class="codehilite"><pre>Axiom Unit : Type := | intro : Unit
Axiom True : True := | intro : Unit
Axiom Null : Set  := | intro : Unit
</pre></div>


<h3 id="void-types-void-and-false">Void Types (Void and False)<a class="headerlink" href="#void-types-void-and-false" title="Permanent link"></a></h3>
<p>The void types are positive types with exactly zero constructors. In other words, they are underivable from any non-contradictory context.</p>
<p>There are two flavors of void types build-in, which are <code>Void : Type</code> and <code>False : Prop</code>. They are defined like so:</p>
<div class="codehilite"><pre>Axiom Void  : Type
Axiom False : Prop
</pre></div>


<p>There is no corresponding void type for <code>Set</code> because youd should never encounter a void in a computational setting!</p>
<h3 id="dependent-type-sums">Dependent Type Sums<a class="headerlink" href="#dependent-type-sums" title="Permanent link"></a></h3>
<p>A dependent type sum has terms of the form</p>
<div class="codehilite"><pre>sum( B x over x:A )
</pre></div>


<p>where <code>A B : Type, B : A → Type</code>. A way to think about it is the disjoint union of types. Dependent sums are defined like so:</p>
<div class="codehilite"><pre>Axiom Sum : ∀ (A B : Type), Type :=
| intro1 : A → Sum A B
| intro2 : B → Sum A B

Pattern &quot;A + B&quot; := Sum A B
</pre></div>


<p>A place where you may have scene this is with <code>Prop</code>&lsquo;s <code>Or</code> disjunction. You could say there&rsquo;s a structural equivelance between <code>A ∨ B</code> and <code>A + B</code>.</p>
<p>Some useful functions for dealing with sums:</p>
<h3 id="dependent-type-product">Dependent Type Product<a class="headerlink" href="#dependent-type-product" title="Permanent link"></a></h3>
<p>A dependent product is a function <code>b : ∀ x:A, B(x)</code> where <code>B : A → Type</code>. A way to think about this is the cartesian product of types. Dependent sums are defined like so:</p>
<div class="codehilite"><pre>Axiom Product : ∀ (A B : Type), Type :=
| intro : A → B → Product A B

Pattern &quot;A * B&quot;
    (A B : Type)
    := Product A B
Pattern &quot;a , b&quot;
    (A B : Type) (a : A) (b : B)
    := intro a b
</pre></div>


<p>A place where you may have scene this is with <code>Prop</code>&lsquo;s <code>And</code> conjunction. You could say there&rsquo;s a structural equivelance between <code>A ∧ B</code> and <code>A * B</code>.</p>
<p>Some useful functions for dealing with products:</p>
<div class="codehilite"><pre>Define fst : A * B → A :=
    axb ↦ match axb with
          | intro a b ↦ a

Define snd : A * B ↦ B :=
    axb ↦ match axb with
          | intro a b ↦ b
</pre></div>


<h3 id="inductive-types">Inductive Types<a class="headerlink" href="#inductive-types" title="Permanent link"></a></h3>
<p>The inductive types are positive types that follow a specific format, allowing a special Induction axiom.</p>
<div class="codehilite"><pre>Inductive Nat : Type :=
| O : Nat
| S : Nat → Nat

// automatically created by program
Axiom Nat.Induction :
    ∀ (P : Nat → Nat) (n : Nat),
        (P Nat.O ∧ P n → P Nat.S n)
    → ∀ n, P n
</pre></div>


<h2 id="vocabulary">Vocabulary<a class="headerlink" href="#vocabulary" title="Permanent link"></a></h2>
<h3 id="headers">Headers<a class="headerlink" href="#headers" title="Permanent link"></a></h3>
<p>Every sentence starts with a header (although it may be implicit). All headers are capitalized. Some example headers are:</p>
<h4 id="axiom"><code>Axiom</code><a class="headerlink" href="#axiom" title="Permanent link"></a></h4>
<p>The <code>Axiom</code> header specifies a new term of an existing type. Note that this term will be considered unique from any other previously-specified terms of the same type. The name &ldquo;Axiom&rdquo; reflects that this header signifies a new assumption. For example, if you have previously defined</p>
<div class="codehilite"><pre>Axiom Bool : Set := | true | false
</pre></div>


<p>and then state</p>
<div class="codehilite"><pre>Axiom x : Bool
</pre></div>


<p>then, from only this information, all other things consistent, you cannot prove that <code>x = true ∨ x = false</code>. In fact, this is actually an insight into how <code>Axiom</code> expands to simplest form. In this case,</p>
<div class="codehilite"><pre>Axiom Bool : Set := | true | false
</pre></div>


<p>expands to</p>
<div class="codehilite"><pre>Axiom Bool : Set
Axiom Bool.constructor : Unit * Unit
Define Bool.true  := fst Bool.constructor
Define Bool.false := snd Bool.constructor
Axiom Bool.match : ∀ (b:Bool)
    , b = Bool.true
    ∨ b = Bool.false
</pre></div>


<p>The <code>match</code> property is needed for performing <code>match</code>s on bools, derived from their only specified constructors. From previously, another example</p>
<div class="codehilite"><pre>Axiom Equal {A : Type} : A → A → Prop :=
| reflexivity : ∀ (x : A), Equal x x
</pre></div>


<p>fully expands to</p>
<div class="codehilite"><pre>Axiom Equal :
    ∀ (A:Type),
    A → A → Prop

Axiom Equal.reflexivity {A:Type} : ∀ (a:A), Equal A x x
</pre></div>


<h4 id="inductive"><code>Inductive</code><a class="headerlink" href="#inductive" title="Permanent link"></a></h4>
<p>The <code>Inductive</code> header indicates that the following type structure has the special inductive property. So the definition of <code>Nat</code> like this:</p>
<div class="codehilite"><pre>Inductive Nat : Set :=
| O : Nat
| S : Nat → Nat
</pre></div>


<p>fully expands to</p>
<div class="codehilite"><pre>Axiom Nat : Set
Axiom Nat.constructor : Unit * (Unit → Unit)
Define Nat.O := fst Nat.constructor
Define Nat.S := snd Nat.constructor
Axiom Nat.match : ∀ (n:Nat)
    , n = Nat.O
    ∨ ∃ (m:Nat), n = Nat.S m
Axiom Nat.Induction : ∀ (P : Nat → Nat) (n : Nat)
    , P Nat.O ∧ P n
    → P Nat.S n
    → ∀ n, P n
</pre></div>


<h4 id="define"><code>Define</code><a class="headerlink" href="#define" title="Permanent link"></a></h4>
<p>The <code>Define</code> header creates a new name that is binded to a term that is constructed using other terms. Note that, differently from <code>Axiom</code>, the binded term is not necessarily unique from any other terms binded by other <code>Defines</code>. For example,</p>
<div class="codehilite"><pre>Define x : Nat := 1
Define y : Nat := 1

Define x_eq_y : x = y
    := Equal.reflexivity 1
</pre></div>


<p>If you run the checks you&rsquo;ll get these</p>
<div class="codehilite"><pre>Check x_eq_y #: x = y
PostCheck x_eq_y #: 1 = 1
</pre></div>


<p><code>PostCheck</code> reflects what will actually be scene when the code is run, as only in the type-checking phase that <code>Check</code> operates in are names not substituted by their bindings.</p>
<h4 id="recursive"><code>Recursive</code><a class="headerlink" href="#recursive" title="Permanent link"></a></h4>
<p>The <code>Recursive</code> header works in almost the same way as the <code>Define</code> header except that it allows recursive definitions, as you may have guessed. Not a lot new here, but take a look at the classic example:</p>
<div class="codehilite"><pre>Recursive fibonacci (n:Nat) : Nat :=
    match n
    | O     ↦ O
    | S O   ↦ S O
    | S S m ↦ fibonacci (S m) + fibonacci (m)
</pre></div>


<p><em>Note:</em> This may end up being merged with <code>Define</code> so that you don&rsquo;t have to distinguish them.</p>
<h4 id="pattern"><code>Pattern</code><a class="headerlink" href="#pattern" title="Permanent link"></a></h4>
<p>The <code>Pattern</code> header is a super useful and versatile macro-creation device. Don&rsquo;t worry about infixes or spaces any longer! Just a simple pattern can take care of almost any notational specialty you&rsquo;d like to include. The notation of <code>Pattern</code> starts with the raw pattern in <code>"</code>s, followed by variables included in the pattern (if any), followed by a <code>:</code> and signature (optional), and finally ended with a <code>:=</code> and binding. The binding may be either a term, or string (using <code>"</code>s). For example, here&rsquo;s a neat way to type playing cards and then reference them.</p>
<div class="codehilite"><pre>Axiom Suite : Set :=
    | Clubs | Spades | Hearts | Diamonds

Axiom Rank  : Set :=
    | Ace   | Two  | Three | Four | Five  | Six  | Seven 
    | Eight | Nine | Ten   | Jack | Queen | King

Axiom Card : Set :=
    | intro : Suite → Rank → Card

Pattern &quot;rank of suite&quot;
    (rank:Rank) (suite:Suite) : Card
    := Card.intro suite rank

# Usage:
Check Two of Spades #&gt; Card
</pre></div>


<p>Additionally, with the easy macro-ing with string outputs, you can quickly implement infixes. For example, with a simple <code>+</code> operator infix:</p>
<div class="codehilite"><pre>Define + := Nat.add
Pattern &quot;n + m&quot; (n m : Nat) := &quot;+ n m&quot;
</pre></div>


<p>This may be eventually implemented as a vocabulary command (like in coq), in some way like</p>
<div class="codehilite"><pre>Define + := Nat.add
Infix 1, + # directly tranlates to the Pattern approach above
</pre></div>


<p><em>Note:</em> When you specify that a variable name is present in a <code>Pattern</code> string, the parser automatically take into consieration that term names can written in slightly different ways with slightly different decorations. For example, taking the previous pattern example, all the following statements will all work in the parser with the defined <code>"rank of suite"</code> pattern:</p>
<div class="codehilite"><pre>Scope Open Suite, Rank # access constructors

Define suite : Suite := Hearts
Overload Define Ace : Type := Void

Define card1 : Card := (Ace:Rank) of suite
Define card2 : Card := (Ace:Rank) of (suite:Suite)
Define card3 : Card := Ace of suite
</pre></div>


<h4 id="overload"><code>Overload</code><a class="headerlink" href="#overload" title="Permanent link"></a></h4>
<h4 id="check"><code>Check</code><a class="headerlink" href="#check" title="Permanent link"></a></h4>
<h4 id="postcheck"><code>PostCheck</code><a class="headerlink" href="#postcheck" title="Permanent link"></a></h4>
<h4 id="compute"><code>Compute</code><a class="headerlink" href="#compute" title="Permanent link"></a></h4>
<h4 id="execute"><code>Execute</code><a class="headerlink" href="#execute" title="Permanent link"></a></h4>
<h3 id="keywords-special-symbols">Keywords / Special Symbols<a class="headerlink" href="#keywords-special-symbols" title="Permanent link"></a></h3>
<p>All keywords are uncapitalized, and neither keywords nor special symbols can be overloaded.</p>
<h4 id="match_1"><code>match</code><a class="headerlink" href="#match_1" title="Permanent link"></a></h4>
<p>To use <code>match</code>, write something like</p>
<div class="codehilite"><pre>match a
| a1 x y ↦ something
| a2 x   ↦ something else
</pre></div>


<p>where <code>a</code> is a term of type <code>A</code>, and each <code>|</code> indicates the start of a function that maps the constructor of <code>A</code> referenced (in this example, <code>a1</code>, and <code>a2</code> are constructors of <code>A</code>). This allows the phrase to evaluate to either something or something else based on what constructor of <code>A</code> that <code>a</code> was built with. In this case, <code>A</code> only has two constructors, <code>a1</code> and <code>a2</code>, but in any match you need to have a function specified to deal with each constructor of the type that you are matching with. The <code>match</code> keyword references the <code>A.match</code> axiom defined (automatically) alongside types when you create them using the constructor (<code>|</code>) syntax.</p>
<p>You may also do some more fancy matching, where you take advantage of nested constructions of terms like so:</p>
<div class="codehilite"><pre>Define bounded_minus3 : Nat → Nat :=
    match n
    | O       ↦ O
    | S O     ↦ O
    | S S O   ↦ O
    | S S S m ↦ m

Recursive pair_max : (Nat,Nat) → Nat :=
    match n,m
    | O,O      ↦ O
    | S q, O   ↦ S q
    | O, S r   ↦ S r
    | S q, S r ↦ pair_max q r
</pre></div>


<h4 id="ifthenelse"><code>if</code>,<code>then</code>,<code>else</code><a class="headerlink" href="#ifthenelse" title="Permanent link"></a></h4>
<p>The typical clause you&rsquo;re familiar with. It has a signature and pattern rule like this</p>
<div class="codehilite"><pre>Scope {A:Type} (b:Bool) (a1 a2:A) : A {

    Define IfElse :=
        match b
        | true ↦ a1
        | false ↦ a2

    Pattern &quot;if condition then a1 else a2&quot; := IfElse condition a1 a2

}
</pre></div>


<h4 id="discriminate_1"><code>discriminate</code><a class="headerlink" href="#discriminate_1" title="Permanent link"></a></h4>
<p>To use <code>disciminate</code>, write something like</p>
<div class="codehilite"><pre>Define true_neq_false
    : false ≠ true
    := discriminate false true
</pre></div>


<p>Discriminating creates a proof of inequality between terms of the same type that are constructed with different constructors. In this case, <code>false</code> and <code>true</code> don&rsquo;t take any arguments so its easy to see. Note that you couldn&rsquo;t write this:</p>
<div class="codehilite"><pre>Define O_neq_S
    : O ≠ S
    := discriminate O S
</pre></div>


<p>because although <code>O</code> and <code>S</code> are constructors of <code>Nat</code>, they have different types, <code>Nat</code> and <code>Nat → Nat</code> respectively. Instead, for this example, you&rsquo;d want to write</p>
<div class="codehilite"><pre>Define O_neq_S
    : ∀ (n:Nat), O ≠ S n
    := discriminate O S
</pre></div>


<p>since discriminating <code>O</code> and <code>S</code> will need to prefix an <code>∀ (n:Nat)</code> for <code>S</code>&lsquo;s argument.</p>
<h4 id="reductio"><code>reductio</code><a class="headerlink" href="#reductio" title="Permanent link"></a></h4>
<p>Using this keyword is the typical way you will construct proofs by reductio ad absurdum.</p>
<div class="codehilite"><pre>Define reductio {A:Prop}
    : (A → False) → ¬ A
    := ...
</pre></div>


<p>The above is a sort of psuedo-definition for term named <code>reductio</code>, however the keyword is different. The format of the above <code>reductio</code>&lsquo;s typing here is to reflect the process of first assuming <code>A</code>, then showing some contradiction, and thus getting <code>¬ A</code> out of the exchange. Contradiction is an extremely common and powerful proof technique for good reason. Instead of using in quite tht way, however, <code>reductio</code> the keyword instead introduces a new goal <code>False</code> and a new assumption <code>A</code> (where <code>A</code> is implied by external typing). Here&rsquo;s a round-about but illuminating example:</p>
<div class="codehilite"><pre>Define true_eq_true : true = true :=    
    reductio
        (contradiction (reflexivity true))
</pre></div>


<p>In this case, <code>Define</code> implies onto</p>
<div class="codehilite"><pre>reductio (contradiction (reflexivity true))
</pre></div>


<p>the type <code>true = true</code>. Then <code>reductio</code> implies onto</p>
<div class="codehilite"><pre>(contradiction (reflexivity true))
</pre></div>


<p>the type <code>(true ≠ true → False)</code>. <code>contradiction</code> determines that since <code>(reflexivity true)</code> has type <code>true = true</code>, it must in total have type <code>contradiction : true = true → true ≠ true → False</code>. As it is applied, this yields the term</p>
<div class="codehilite"><pre>(contradiction (reflexivity true))
</pre></div>


<p>to have the right type for <code>reductio</code> to use, so the term is successfully defined!</p>
<p><em>Note:</em> <code>reductio</code> may not even need to be a keyword I guess I just have to define it properly.</p>
<h4 id="letin"><code>let</code>,<code>in</code><a class="headerlink" href="#letin" title="Permanent link"></a></h4>
<p>Starting an expression with <code>let</code> indicates that everything between the <code>let</code> and following <code>in</code> should be treated as locally defined in a scope containing the expressions after the <code>let</code> and the final expression after the <code>in</code>, and this local scope cannot be accessed from outside (its a temporary scope). For example,</p>
<div class="codehilite"><pre>Define x :=
    let
        a := 1
        b := 2
        c := 3
    in
        a + b + c

Compute x #&gt; 6
</pre></div>


<p>Only <code>Define</code> headers may be used inside the <code>let</code>,<code>in</code> clause, and if they are left out they are implied, as they are in the example above.</p>
<h4 id="where"><code>where</code><a class="headerlink" href="#where" title="Permanent link"></a></h4>
<p><code>where</code> clauses work in the same way as <code>let</code>,<code>in</code> clause, but with a different ordering. Ending an expression with <code>where</code> indicates that the clause following the <code>where</code> will be a temporary scope in following the same rules as a <code>let</code>,<code>in</code> that is accessable by the expression preceeding the <code>where</code>. Rewriting the example in <code>let</code>,<code>in</code> section,</p>
<div class="codehilite"><pre>Define x := a + b + c
    where
        a := 1
        b := 2
        c := 3
</pre></div>


<p>Deciding between <code>let</code>,<code>in</code> clauses and <code>where</code> clauses is a purely aesthetic desicion.</p>
<h4 id="introduce"><code>introduce</code><a class="headerlink" href="#introduce" title="Permanent link"></a></h4>
<p>Sometimes when building proof terms, you may have something that looks like</p>
<div class="codehilite"><pre>... Nat → Nat → Prop
</pre></div>


<p>where in building the term you&rsquo;d like to reference the actual terms by name that are going to be provided when this proof is used. The name <code>intro</code> borrows from Coq and works in a very similar way. For example,</p>
<div class="codehilite"><pre>Recursive Nat.add : Nat → Nat → Nat :=
    match n,m
    | O  , _   ↦ n
    | _  , O   ↦ m
    | S q, S r ↦ S S (Nat.add q r)
    where
        introduce n,m
</pre></div>


<p><code>introduce</code> will create as many names as you provide that correspond to variables of the parenthetical expressions between outer arrows, from left to right, in the typing of the name <code>Recursive</code> is currently defining, and stopping at the last outer arrow. An <em>outer</em> arrow is one that isn&rsquo;t contained by any explicit parentheses that begin after the colon. Remember that <code>→</code> associates right, so</p>
<div class="codehilite"><pre>Nat → Nat → Nat
</pre></div>


<p>parenthetically expands to</p>
<div class="codehilite"><pre>Nat → (Nat → (Nat))
</pre></div>


<p>making the intro sequence as expected from left to right, one <code>Nat</code> at a time. However, if you had typed <code>add</code> like this</p>
<div class="codehilite"><pre>Recursive Nat.add : (Nat → Nat) → Nat :=
    let
        introduce f #: Nat → Nat
    in
        # don&#39;t end up using f at all...
        n m ↦
        match n,m
        | O  , _   ↦ n
        | _  , O   ↦ m
        | S q, S r ↦ S S (Nat.add q r)
</pre></div>


<p>things wouldn&rsquo;t be working out as planned probably, since <code>f</code> is a single-arity function and not really useful in the example.</p>
<p>Also remember that if you already named the variables on either side of the colon in a way like this</p>
<div class="codehilite"><pre>Recursive Nat.add (n:Nat) : ∀ (m:Nat), Nat :=
    match n,m
    | O  , _   ↦ n
    | _  , O   ↦ m
    | S q, S r ↦ S S (Nat.add q r)
# n and m were named as variables already
</pre></div>


<p>then you don&rsquo;t need to use intro at all! These techniques can be combined as well:</p>
<div class="codehilite"><pre>Recursive Nat.make_adder (n:Nat) : Nat → Nat :=
    match n,m
    | O  , _   ↦ n
    | _  , O   ↦ m
    | S q, S r ↦ S S (Nat.add q r)
    where
        introduce m
</pre></div>


<p>This may seem like a sort of gimmick, but it actually is a great way to make you code readable when you start to have complicated <code>let</code> or <code>where</code> clauses in which you either nest clauses or work with subgoals. Note that when you nest <code>where</code>s, the outer name&rsquo;s signature will not be avaliable to <code>introduce</code>, and only the <code>where</code> clause&rsquo;s immediate target will be. For example,</p>
<div class="codehilite"><pre>Define true_eq_true : true = true :=
    let
        r_pf : true ≠ true → False := counter
            where
                introduce true_neq_true
                counter := contradiction
                    (reflexivity true)
                    true_neq_true
    in
        reductio r_pf
</pre></div>


<p>At the second <code>where</code> we are entering name &ldquo;pf&rdquo;, so the introduction expressions order looks like, from this scope,</p>
<div class="codehilite"><pre>true ≠ true → False
</pre></div>


<p>This is important because when <code>introduce</code> is used, it takes the <code>true ≠ true</code>.</p>
<h6 id="_1"><code>:</code><a class="headerlink" href="#_1" title="Permanent link"></a></h6>
<h6 id="_2"><code>→</code><a class="headerlink" href="#_2" title="Permanent link"></a></h6>
<h6 id="_3"><code>|</code><a class="headerlink" href="#_3" title="Permanent link"></a></h6>
<h6 id="_4"><code>↦</code><a class="headerlink" href="#_4" title="Permanent link"></a></h6>
<h6 id="_5"><code>∀</code><a class="headerlink" href="#_5" title="Permanent link"></a></h6>
<h6 id="_6"><code>∃</code><a class="headerlink" href="#_6" title="Permanent link"></a></h6>
<p>See <a href="#exists-statement">Exists Statement</a></p>
<h2 id="type-judgements">Type Judgements<a class="headerlink" href="#type-judgements" title="Permanent link"></a></h2>
<p>A type judgement is of the form</p>
<div class="codehilite"><pre>term : type
</pre></div>


<p>where the <code>:</code> importantly seperates them. A type judgement asserts that the <code>term</code> has the type <code>type</code>.</p>
<h3 id="term">Term<a class="headerlink" href="#term" title="Permanent link"></a></h3>
<p>A term is a name that inhabits a type.</p>
<h3 id="type">Type<a class="headerlink" href="#type" title="Permanent link"></a></h3>
<p>A type is a name the provides structure and rules for its terms.</p>
<h3 id="signature">Signature<a class="headerlink" href="#signature" title="Permanent link"></a></h3>
<p>A signature is a construction of types using type names, parameters, and function arrows. For example, if we take</p>
<div class="codehilite"><pre>Axiom A : B → C → Type :=
| intro b c : A b c
Axiom b : B
Axiom c : C
</pre></div>


<p>and form</p>
<div class="codehilite"><pre>Define a := A.intro b c
</pre></div>


<p>Then we can correctly judge that</p>
<div class="codehilite"><pre>a : A
</pre></div>


<p>More simply, we can just</p>
<div class="codehilite"><pre>Check a #&gt; a : A
</pre></div>


<h3 id="variables-in-sigantures">Variables in Sigantures<a class="headerlink" href="#variables-in-sigantures" title="Permanent link"></a></h3>
<p>In signatures, you may want to refer to the same value more than once. To do this, there are a few special ways to include variables in signatures. They are detailed in the next two sub-sections, but below is a comprehensive list:</p>
<div class="codehilite"><pre># Explicit parameters come before the colon,
# and if types are specified, parentheses surround inidividual
# parameters, or optionally parameters of the same type can
# be seperated by spaces in the same parenthetic group.

Axiom f (x : Real) : Real     #: Real → Real
Axiom g (x y z : Real) : Real #: Real → Real → Real → Real

# Can also be done like this

Define add_one : ∀ (x:Nat), Nat := x ↦ S x #: Nat → Nat
Pattern &quot;x + 1&quot; (x:Nat) : Nat := add_one

# Implicit parameters come before the colon
# and also before any explicit parameters.
# Scopes can have parameters that are inherited
# by the enscoped names.

Scope {X : Set} (f : Real → X) (g : X → Real) {
    Define compose  := (x : Real) ↦ g (f x)
    Pattern &quot;g * f&quot; := compose g f
    #: {X : Set} (f : Real → X) (g : X → Real)
}

Define h := g * f #: Real → Real

# Can also do this neat trick

# Scoped names can inherit types too

Axiom Bool : Type := | true | false

Scope Bool (b:Bool) : Bool {
    # the first &quot;Bool&quot; scopes inside the name
    # the &quot;b:Bool&quot; variable indicates that names
    # inside this scope have this first explicit variable
    # the second &quot;Bool&quot; indicates the names inside
    # this scope have signatures that end with Bool
    Define not := match b | false | true #: Bool → Bool
}
</pre></div>


<h4 id="explicits">Explicits<a class="headerlink" href="#explicits" title="Permanent link"></a></h4>
<p>You may write explicit variables either before or after the colon, but each way has a unique syntax. If the types of the variables are specified, parentheses are required around the variable names and their types.</p>
<p>Before the colon (parameter syntax):</p>
<div class="codehilite"><pre>Define f (a b c : Nat) : Nat := a * b + c * d
#: Nat → Nat → Nat → Nat
</pre></div>


<p>After the colon (&ldquo;forall&rdquo; syntax):</p>
<div class="codehilite"><pre>Axiom f : ∀ (a b c d: Nat) : Nat := a b c d ↦ a * b + c * d
#: Nat → Nat → Nat → Nat
</pre></div>


<p>The difference netween these, as you may notice, is that in the &ldquo;forall&rdquo; syntax the right side of the <code>:=</code> must example have the type specified by the right side of the colon of the type judgement, whereas in the parameter syntax the variables didn&rsquo;t appear on the right side of the colon for judging <code>f</code>, so the <code>a b c d</code> didn&rsquo;t need to be repeated, and just the resulting <code>Nat</code> value of <code>a * b + c * d</code> needed to be stated.</p>
<p>Because of this, the parameter syntax is a little more flexible, but the &ldquo;forall&rdquo; syntax can be more flavorful and expressive sometimes, as well as allowing outer types to contain variables, such as in</p>
<div class="codehilite"><pre>Axiom liebniz (n m: Nat) : n = m → ∀ (P:Nat→Nat), P n → P m
Define props_for_one := liebniz 1 1 (Equal.reflexivity 1)
#: ∀ (P:Nat→Nat), P 1 → P 1
</pre></div>


<h4 id="implicits">Implicits<a class="headerlink" href="#implicits" title="Permanent link"></a></h4>
<p>You may only write implicit variables before the colon, before any expicit variables. Implicit variables are unique in that they are tagged to require inference when they are used. For example,</p>
<div class="codehilite"><pre>Define id {A:Type} (a:A) := a #: A → A
</pre></div>


<p>The <code>{A:Type}</code> is not included in the signature of the name <code>id</code>, since the parameter is not to be given when using the name. There is a little flexibility to this though. You can specifically pass implict parameters like so:</p>
<div class="codehilite"><pre>Compute id {Set} 1 #&gt; 1
</pre></div>


<p>This can be useful if there are times when you may be using symbols for multiple things (overloading), which is fine but required explicit typing sometimes.</p>
<h4 id="exists-statement">Exists Statement<a class="headerlink" href="#exists-statement" title="Permanent link"></a></h4>
<p>In signatures, you can say that something has the type <code>∃ (x:A), Px</code> where <code>x</code> is a variable name, <code>A</code> is a type, and the <code>Px</code> is a <code>Prop</code> about <code>x</code>. For example you might say</p>
<div class="codehilite"><pre>Axiom nat_has_no_maximum:
    ∀ (n:Nat), ∃ (m:Nat), n &lt; m
</pre></div>


<p><code>∃ x, Px</code> is really just notation for the <code>InhabitedDomain</code> type:</p>
<div class="codehilite"><pre>Axiom InhabitedDomain {A:Type} (P:A→Prop) : Prop :=
| intro {A:Type} {P:A→Prop} (wt : A) (pf : P wt) : InhabitedDomain P

Pattern &quot;∃ x, Px&quot;
    {A:Type} (x:A) (Px:Prop) : Prop
    := &quot;InhabitedDomain (x ↦ Px)&quot;
</pre></div>


<p>Here&rsquo;s some more notation for the lengthy <code>InhabitedDomain.intro</code> constructor:</p>
<div class="codehilite"><pre>Pattern &quot;example wt pf&quot;
    {A:Type} {P:A→Prop} (wt:A) (pf:A→Prop) : InhabitedDomain P
    := InhabitedDomain.intro wt pf
</pre></div>


<p>So, we can write the original axiom in its expanded form</p>
<div class="codehilite"><pre>Axiom nat_has_no_maximum: ∀ (n:Nat), InhabitedDomain (m ↦ n &lt; m)
</pre></div>


<p>To prove this rather than take it as an axiom:</p>
<div class="codehilite"><pre>Define nat_has_no_maximum: ∀ (n:Nat), InhabitedDomain (m ↦ n &lt; m) :=
    let
        wt := Nat.S n        #: Nat
        pf (n:Nat) := Lt.S n #: ∀ (n:Nat), n &lt; S n
    in
        InhabitedDomain.intro wt pf
</pre></div>


<p>Or we can do it this way, of course as inspired by Haskell&rsquo;s unforgettable <code>where</code> syntax:</p>
<div class="codehilite"><pre>Define nat_has_no_maximum: ∀ (n:Nat), InhabitedDomain (m ↦ n &lt; m) :=
    InhabitedDomain.intro wt pf
    where
        wt := Nat.S n        #: Nat
        pf (n:Nat) := Lt.S n #: ∀ (n:Nat), n &lt; S n
</pre></div>


<p>The writing out of <code>InhabitedDomain</code> and its slightly counter-intuitive formatting makes using the <code>∃ x, Px</code> pattern the most efficient in most cases, like this final proof (in quickest form) demonstrates:</p>
<div class="codehilite"><pre>Define nat_has_no_maximum : ∀ (n:Nat), ∃ (x:Nat), n &lt; m :=
    example wt pf
    where # succ of n is always greater than n, by Lt.S
        wt := Nat.S n
        pf (n:Nat) := Lt.S n
</pre></div>


<h2 id="names">Names<a class="headerlink" href="#names" title="Permanent link"></a></h2>
<p>To use a name, first type the name, then supply as many parameters as you want like so:</p>
<div class="codehilite"><pre>name var1 var2 var3 ...
</pre></div>


<h3 id="associativity">Associativity<a class="headerlink" href="#associativity" title="Permanent link"></a></h3>
<ul>
<li><strong>Left Associativity</strong>: A B C -→ (A B) C</li>
<li><strong>Right Associativity</strong>: A B C -→ A (B C)</li>
</ul>
<p>The rules for associativity are outlined here, in order from greatest to least priority:</p>
<table>
<thead>
<tr>
<th>Phrase</th>
<th>Rule</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vocab</td>
<td>left</td>
<td>Scope Open Nat ==&gt; (Scope Open) Nat</td>
</tr>
<tr>
<td>∃ x, Px</td>
<td>right</td>
<td>∃x, ∃y, ∃z, x=y=z ==&gt; ∃x, (∃y, ∃z, x=y=z)</td>
</tr>
<tr>
<td>∀ x, Px</td>
<td>right</td>
<td>∀x, ∀y, ∀z, x=y=z ==&gt; ∀x, (∀y, ∀z, x=y=z)</td>
</tr>
<tr>
<td>↦</td>
<td>right</td>
<td>x ↦ y ↦ z ==&gt; x ↦ (y ↦ z)</td>
</tr>
<tr>
<td>→</td>
<td>left</td>
<td>A → B → C ==&gt; (A → B) → C</td>
</tr>
<tr>
<td>default</td>
<td>left</td>
<td>f g h ==&gt; (f g) h</td>
</tr>
</tbody>
</table>
<h2 id="compilation">Compilation<a class="headerlink" href="#compilation" title="Permanent link"></a></h2>
<p>Compiling a Craft program is divided into several phases:</p>
<ol>
<li><strong>Expansion</strong></li>
</ol>
<p>The compiler scans through the  program and fully expands all expressions. This means adding in parentheses and seperating variable spaces and all that, as well as shifting everything other than names to the right of the type judgement <code>:</code>s. Observe:</p>
<div class="codehilite"><pre>Define f x := x + 1
Define lemma : ∃ (x y:Bool), x = y ∧ x = false
</pre></div>


<p>expands to</p>
<div class="codehilite"><pre>(
    (
        (Define)
        (f)
    )
    (:)
    (
        (∀) (x:?)
    )
    (:=)
    (
        (x) + (1)
    )
)

(
    (
        (Define)
        (lemma)
    )
    (:)
    (
        ((∃) (x:Bool)),
        (
            ((∃) (y:Bool)),
            (
                ( ((x) =) (y) )
                (∧)
                ( ((x) =) (false) )
            )
        )
    )
)
</pre></div>


<p>The parentheses all are exactly resulting from associativity rules. The <code>?</code>s indicates that a typing was expected, but none was given explicitly. So, the <code>?</code>s are to be infered by the type checking process.</p>
<ol>
<li><strong>Patterns</strong></li>
</ol>
<p>The compiler specifically looks for <code>Pattern</code> declarations, and ignores everything else. The scope of the <code>Pattern</code> declarations are noted.</p>
<ol>
<li><strong>Parsing</strong></li>
</ol>
<p>THe compiler makes sure that syntax rules are followed correctly in all lines of the program. Instances where a pattern <em>may</em> be applied are tagged with the possible patterns that could possibly apply there. In the type checking phase, the correct interpretation (if any) will be determined. Errors that result from this pattern parsing (if no possible interpretation type-checks) will be a type checking error thrown in the next section.</p>
<ol>
<li><strong>Type Checking</strong></li>
</ol>
<p>Next, the type checker checks each module, in a tree leaf-to-root fashion of independence, for correct typings.</p>
<ol>
<li><strong>Execution</strong></li>
</ol>
<p><code>Execute</code>s are run.</p>
<h2 id="values">Values<a class="headerlink" href="#values" title="Permanent link"></a></h2>
<p>Value are represented differently in three sequencial phases.</p>
<ol>
<li><strong>Referencing Values</strong></li>
</ol>
<p>Lazily-bound value are how your names are initially interpretted by the compiler. When you write something like</p>
<div class="codehilite"><pre>Define x : Nat := 1
</pre></div>


<p>The name <code>x</code> is bound to the value <code>1</code>. This means that, via a beta-reduction application, <code>x</code> reduces to <code>1</code>. However, this reduction is only guranteed to have been performed by then end of the <code>Reducing Values</code> step.</p>
<p>This type of reduction applies to functions as well. For example in,</p>
<div class="codehilite"><pre>Define not (b:Bool) := match b | true↦false | false↦true
Define not_false := not false
</pre></div>


<p><code>not_false</code> is bound to <code>not false</code>. Only via a beta-reduction step can we reduce this binding to <code>true</code>.</p>
<ol>
<li><strong>Reducing Values</strong></li>
</ol>
<p>Values are &lsquo;computed&rsquo; via applying beta-reduction until terms are completely reduced. For example, if we had</p>
<div class="codehilite"><pre>Define a := 1
Define b (x:Nat) := a
Define c := b 2
Define d := c
</pre></div>


<p>the then the steps to find the value of <code>Compute c</code> are</p>
<div class="codehilite"><pre>Compute c
==&gt; d
==&gt; c
==&gt; b 2
==&gt; a
==&gt; 1
</pre></div>


<ol>
<li><strong>Returning Values</strong></li>
</ol>
<p>The process of <em>returning</em> is critically different from the process of <em>computing/reducing</em>. All terms can reduce, but only <em>executable</em> terms can return. So what&rsquo;s an executable term? Generally, these are referred to as monads. Monads are special in that they do not describe a value but instead describe a process for obtaining a value. A Monad always has specifies its return type as the type of the term that can be expected to be obtained when the monad is executed. To obtain this value, use the header <a href="#execute"><code>Execute</code></a>, as described in the Headers section.</p>
<h2 id="scopes">Scopes<a class="headerlink" href="#scopes" title="Permanent link"></a></h2>
<h3 id="named-scopes">Named Scopes<a class="headerlink" href="#named-scopes" title="Permanent link"></a></h3>
<h4 id="unparametrized-scopes">Unparametrized Scopes<a class="headerlink" href="#unparametrized-scopes" title="Permanent link"></a></h4>
<h4 id="parametrized-scopes">Parametrized Scopes<a class="headerlink" href="#parametrized-scopes" title="Permanent link"></a></h4>
<h3 id="anonymous-scopes">Anonymous Scopes<a class="headerlink" href="#anonymous-scopes" title="Permanent link"></a></h3>
<h3 id="modules">Modules<a class="headerlink" href="#modules" title="Permanent link"></a></h3></article></body></html>